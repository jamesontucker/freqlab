#include "PluginProcessor.h"
#include "IPlug_include_in_plug_src.h"
#include <cmath>

using namespace iplug;

{{pascal_name}}::{{pascal_name}}(const InstanceInfo& info)
    : iplug::Plugin(info, MakeConfig(kNumParams, 1))  // params, presets
{
    // Define parameters
    GetParam(kGain)->InitDouble("Gain", -6., -70., 12., 0.1, "dB");

    // Initialize cached values
    mGain = DBToAmp(GetParam(kGain)->Value());

#if IPLUG_EDITOR
    // WebView editor setup - load bundled HTML
    mEditorInitFunc = [&]() {
        LoadFile("ui.html", GetBundleID());
    };
#endif
}

void {{pascal_name}}::OnReset() {
    mPhase = 0.0;
}

void {{pascal_name}}::OnParamChange(int paramIdx) {
    switch (paramIdx) {
        case kGain:
            mGain = DBToAmp(GetParam(kGain)->Value());
            break;
    }
}

void {{pascal_name}}::ProcessMidiMsg(const IMidiMsg& msg) {
    switch (msg.StatusMsg()) {
        case IMidiMsg::kNoteOn:
            if (msg.Velocity() > 0) {
                mFreq = 440.0 * std::pow(2.0, (msg.NoteNumber() - 69) / 12.0);
                mVelocity = msg.Velocity() / 127.0;
                mNoteOn = true;
            } else {
                mNoteOn = false;
            }
            break;
        case IMidiMsg::kNoteOff:
            mNoteOn = false;
            break;
        default:
            break;
    }
}

void {{pascal_name}}::ProcessBlock(sample** inputs, sample** outputs, int nFrames) {
    const int nChans = NOutChansConnected();
    const double sampleRate = GetSampleRate();
    const double gain = mGain;

    for (int s = 0; s < nFrames; s++) {
        double out = 0.0;

        if (mNoteOn && mFreq > 0.0) {
            // Simple sine wave oscillator
            out = std::sin(mPhase * 2.0 * M_PI) * mVelocity * gain;
            mPhase += mFreq / sampleRate;
            if (mPhase >= 1.0) mPhase -= 1.0;
        }

        if (!std::isfinite(out)) {
            out = 0.0;
        }

        for (int c = 0; c < nChans; c++) {
            outputs[c][s] = out;
        }
    }
}
